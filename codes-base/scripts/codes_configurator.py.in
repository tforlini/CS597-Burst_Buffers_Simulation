#!/usr/bin/python2.7

#
# Copyright (C) 2014 University of Chicago.
# See COPYRIGHT notice in top-level directory.
#
#

import os
import argparse
import imp

# internal testing: import directly
#import configurator as conf

# dynamically load from lib path
def import_from(fname):
    path,name = os.path.split(fname)
    name,ext  = os.path.splitext(name) 

    fmod, fname, data = imp.find_module(name, [path])
    return imp.load_module(name,fmod,fname,data)

conf = import_from("@libdir@/configurator.py")

def main():
    args = parse_args()
    
    # load the template file
    tstr = open(args.template).read()

    # load the module
    mod = conf.import_from(args.substitute_py)

    # intitialize the configuration object 
    cfg = conf.configurator(mod, args.token_pairs)

    # print the header to the log
    if args.log != None:
        flog = open(args.log, "w")
    else:
        flog = open(os.devnull, "w")
    
    cfg.write_header(flog)

    # main loop (cfg iterator returns nothing, eval'd for side effects)
    for i,_ in enumerate(cfg):
        new_config = conf.replace_many(tstr, cfg.replace_map)
        fname = template+"."+str(i) if args.output_prefix==None else \
                args.output_prefix +"." + "{:05d}".format(i)
        with open(fname, "w") as fout:
            fout.write(new_config)
        
        # write this config to the log 
        cfg.write_config_line(i, flog)

    flog.close()

sub_help = \
'python file defining "cfields" variable consisting of a sequence of <name, ' \
'value sequence> pairs. The following variables may optionally appear. ' \
'"exceptions" - a sequence of dictionaries. Each configuration generated by ' \
'"cfields" is checked against each dictionary in "exceptions"; if each value ' \
'in the dict matches that of the configuration, then that configuration is ' \
'skipped. "cfields_derived_labels", "cfields_derived" - the former is a ' \
'sequence of strings identifying replace tokens that will be dynamically set ' \
'based on the input configuration generated by cfields. The latter is a ' \
'function that adds all <name,value> pairs for names in ' \
'"cfields_derived_labels".'

def parse_args():
    parser = argparse.ArgumentParser(\
            description="generate set of configuration files based on template "
                        "file and replacement tokens")
    parser.add_argument("template",
            help="template file with replace tokens")
    parser.add_argument("substitute_py",
            help=sub_help)
    parser.add_argument("token_pairs", nargs='*',
            help="a list of whitespace-separated token, replace pairs for "
                 "command-line-driven replacement (useful in shell scripts "
                 "for generating sets of configuration files with a distinct "
                 "parameter or for special casing fields)")
    parser.add_argument("-l", "--log",
            help="log file to write parameterizations to")
    parser.add_argument("-o", "--output_prefix",
            help="prefix to output generated configuration files to "
                 "(default: the configuration index appended to the template name)")
    return parser.parse_args()

if __name__ == "__main__":
    main()
